# FibonacciTestProject

**Описание задачи**

Два приложения общаются друг с другом через транспорты, реализуя расчет чисел Фибоначчи.
1. Логика расчета одной последовательности такая:
2. Первое инициализирует расчет.
3. Первое отправляет второму N_I
4. Второе вычисляет N_(I – 1) + N_I и шлет обратно
5. Логика повторяется симметрично.
6. И так до остановки приложений.

Особенности:
- Первое приложение при старте получает параметр – целое число, сколько асинхронных расчетов начать. Все расчеты идут параллельно.
- Передача данных от 1 к 2 идет через Rest WebApi
- Передача данных от 2 к 1 идет посредством MessageBus.

Язык C#, среда MS .NET Framework версии от 4.0.

Рекомендуемые технологии:
-REST: ASP.NET WebApi + HttpClient
-MessageBus: RabbitMQ + EasyNetQ.


**Комментарии к решению**

Сделано 2 консольных приложения: WebApiApp1 и App2. В конфигурационных файлах проектов App.config необходимо задать адрес, на котором будет развернут HttpListener для WebApi, а также строку подключения к RabbitMQ. Также в Nlog.config можно задать конфигурацию для логирование в приложении. По умолчанию все сообщения логируются в консоль и в файл рядом с исполняемым файлом.

 Запустить оба приложения можно с бомощью bat файла в корне солюшна. startApps1 запустит одну последовательность вычисления, startApps10 - десять и т.д. Для этого надо собрать приложение в Release конфигурации.

Максимальное число Фибоначчи, которое сейчас могут вычислить приложения ограничивается возможностью библиотеки Newtonsoft.Json, который не может десерилизовать числа больше 380 символов. Можно решить с помощью сторонних парсеров, тогда следующим ограничением станет невозможность выделить память под число (OutOfMemoryException).

Про ограничение в Newtonsoft.Json: 
private const int MaximumJavascriptIntegerCharacterLength = 380;
https://github.com/exceptionless/Exceptionless.Net/blob/master/src/Exceptionless/Newtonsoft.Json/JsonTextReader.cs

Ни одно из приложений не хранит дополнительных сведений для расчёта следующего числа за счёт того, что предыдущее число так же передается при помощи транспорта. При запуске большого кол-ва параллельных вычислений узким местом становится web api, но так как мы не храним состояний, то сервис легко масштабировать горизонтально. 